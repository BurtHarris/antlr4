// [The "BSD license"]
//  Copyright (c) 2013 Terence Parr
//  Copyright (c) 2013 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  Copyright (c) 2016 Burt Harris
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import {Token} from '../Token';

import { LL1Analyzer } from './../LL1Analyzer';
import { IntervalSet } from './../IntervalSet';

export class ATN {
    static INVALID_ALT_NUMBER = 0;
    
    states = [];
    // Each subrule/rule is a decision point and we must track them so we
    //  can go back later and build DFA predictors for them.  includes
    //  all the rules, subrules, optional blocks, ()+, ()* etc...
    decisionToState = [];
    // Maps from rule index to starting state number.
    ruleToStartState = [];
    // Maps from rule index to stop state number.
    ruleToStopState = null;
    modeNameToStartState = {};
    // For lexer ATNs, this maps the rule index to the resulting token type.
    // For parser ATNs, this maps the rule index to the generated bypass token
    // type if the
    // {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
    // deserialization option was specified; otherwise, this is {@code null}.
    ruleToTokenType = null;
    // For lexer ATNs, this is an array of {@link LexerAction} objects which may
    // be referenced by action transitions in the ATN.
    lexerActions = null;
    modeToStartState = [];

    constructor(public grammarType, public maxTokenType) {
    }

    // Compute the set of valid tokens that can occur starting in state {@code s}.
    //  If {@code ctx} is null, the set of tokens will not include what can follow
    //  the rule surrounding {@code s}. In other words, the set will be
    //  restricted to tokens reachable staying within {@code s}'s rule.
    nextTokensInContext(s, ctx) {
        var anal = new LL1Analyzer(this);
        return anal.LOOK(s, null, ctx);
    };

    // Compute the set of valid tokens that can occur starting in {@code s} and
    // staying in same rule. {@link Token//EPSILON} is in set if we reach end of
    // rule.
    nextTokensNoContext(s) {
        if (s.nextTokenWithinRule !== null) {
            return s.nextTokenWithinRule;
        }
        s.nextTokenWithinRule = this.nextTokensInContext(s, null);
        s.nextTokenWithinRule.readOnly = true;
        return s.nextTokenWithinRule;
    };

    nextTokens(s, ctx?) {
        if (ctx === undefined) {
            return this.nextTokensNoContext(s);
        } else {
            return this.nextTokensInContext(s, ctx);
        }
    };

    addState(state) {
        if (state !== null) {
            state.atn = this;
            state.stateNumber = this.states.length;
        }
        this.states.push(state);
    };

    removeState(state) {
        this.states[state.stateNumber] = null; // just free mem, don't shift states in list
    };

    defineDecisionState(s) {
        this.decisionToState.push(s);
        s.decision = this.decisionToState.length - 1;
        return s.decision;
    };

    getDecisionState(decision) {
        if (this.decisionToState.length === 0) {
            return null;
        } else {
            return this.decisionToState[decision];
        }
    };

    // Computes the set of input symbols which could follow ATN state number
    // {@code stateNumber} in the specified full {@code context}. This method
    // considers the complete parser context, but does not evaluate semantic
    // predicates (i.e. all predicates encountered during the calculation are
    // assumed true). If a path in the ATN exists from the starting state to the
    // {@link RuleStopState} of the outermost context without matching any
    // symbols, {@link Token//EOF} is added to the returned set.
    //
    // <p>If {@code context} is {@code null}, it is treated as
    // {@link ParserRuleContext//EMPTY}.</p>
    //
    // @param stateNumber the ATN state number
    // @param context the full parse context
    // @return The set of potentially valid input symbols which could follow the
    // specified state in the specified context.
    // @throws IllegalArgumentException if the ATN does not contain a state with
    // number {@code stateNumber}

    getExpectedTokens(stateNumber, ctx) {
        if (stateNumber < 0 || stateNumber >= this.states.length) {
            throw ("Invalid state number.");
        }
        var s = this.states[stateNumber];
        var following = this.nextTokens(s);
        if (!following.contains(Token.EPSILON)) {
            return following;
        }
        var expected = new IntervalSet();
        expected.addSet(following);
        expected.removeOne(Token.EPSILON);
        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
            var invokingState = this.states[ctx.invokingState];
            var rt = invokingState.transitions[0];
            following = this.nextTokens(rt.followState);
            expected.addSet(following);
            expected.removeOne(Token.EPSILON);
            ctx = ctx.parentCtx;
        }
        if (following.contains(Token.EPSILON)) {
            expected.addOne(Token.EOF);
        }
        return expected;
    };
}
